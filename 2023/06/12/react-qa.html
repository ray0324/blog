<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"><title>React中常见问题</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/lib/highlight/styles/atom-one-dark.css"></head><body><header class="navbar navbar-fixed"><div class="navbar-nav"><div class="container"><a class="brand"></a><ul><li><a href="/">首页</a></li><li><a href="/archives/">归档</a></li><li><a href="/tags/">标签</a></li><li><a href="/about/">关于</a></li></ul></div></div><div class="navbar-line"><div class="navbar-wrap"><div class="container current"><div class="cur"></div></div></div></div></header><div class="main"><div class="container post"><h1>React中常见问题</h1><div class="meta"><time>2023-06-12</time><div class="tags"><a class="tag-link" href="/tags/React/">React </a></div></div><article id="markdown"><h2 id="React-中-useMemo-和-useCallback-区别"><a href="#React-中-useMemo-和-useCallback-区别" class="headerlink" title="React 中 useMemo 和 useCallback 区别"></a>React 中 useMemo 和 useCallback 区别</h2><p>useMemo 和 useCallback 是 React Hooks 提供的一些自定义 Hook，用于优化性能和避免不必要的计算。</p>
<p>useMemo 用于缓存计算结果，只有当依赖项发生变化时，才会重新计算结果。它通常用于计算一些不会频繁变化的复杂数据，例如从 API 获取的数据或需要大量计算的数据。</p>
<p>useCallback 用于缓存函数，只有当依赖项发生变化时，才会重新创建函数。它通常用于缓存事件处理程序或需要频繁调用的函数，以避免不必要的函数创建和销毁。</p>
<p>以下是它们的主要区别：</p>
<ol>
<li>useMemo 返回计算结果，而 useCallback 返回函数引用。</li>
<li>useMemo 的依赖项可以是任何可以比较的值（例如字符串、数字、对象），而 useCallback 的依赖项必须是函数或类实例。</li>
<li>useMemo 的返回值可以在组件渲染时使用，而 useCallback 的返回值只能用于回调函数中。</li>
<li>useMemo 可以接受一个可选的初始值参数，如果没有提供初始值，则返回第一个依赖项的结果。而 useCallback 必须至少提供一个依赖项。
综上所述，useMemo 更适用于缓存计算结果，而 useCallback 更适用于缓存函数。</li>
</ol>
<h3 id="useCallback-示例"><a href="#useCallback-示例" class="headerlink" title="useCallback 示例"></a>useCallback 示例</h3><pre><code class="js">import React, { useState, useCallback } from &#39;react&#39;;

function App() {
  const [count, setCount] = useState(0);

  const handleClick = useCallback(() =&gt; {
    setCount(count + 1);
  }, [count]);

  return (
    &lt;div&gt;
      &lt;p&gt;count: {count}&lt;/p&gt;
      &lt;button onClick={handleClick}&gt;+1&lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<h3 id="useMemo-示例"><a href="#useMemo-示例" class="headerlink" title="useMemo 示例"></a>useMemo 示例</h3><pre><code class="js">import React, { useState, useMemo } from &#39;react&#39;;

function App() {
  const [count, setCount] = useState(0);

  const result = useMemo(() =&gt; {
    console.log(&#39;compute&#39;);
    return count * 2;
  }, [count]);

  return (
    &lt;div&gt;
      &lt;p&gt;count: {count}&lt;/p&gt;
      &lt;p&gt;result: {result}&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;+1&lt;/button&gt;
      &lt;button onClick={() =&gt; setCount(count)}&gt;1&lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<h2 id="React-中-useMemo-和-memo-有何区别"><a href="#React-中-useMemo-和-memo-有何区别" class="headerlink" title="React 中 useMemo 和 memo 有何区别"></a>React 中 useMemo 和 memo 有何区别</h2><p>React 中 useMemo 和 memo 的区别如下</p>
<ul>
<li>memo 是一个高阶组件，而 useMemo 是一个 React Hook。</li>
<li>memo 用于包装不想重新渲染的组件，而 useMemo 用于包装函数，以确保该函数中的值仅在其依赖项之一发生变化时才重新计算。</li>
<li>memo 会跳过渲染组件并重用上次渲染的结果，而 useMemo 不会改变组件的渲染过程。</li>
</ul>
<pre><code class="js">import React, { memo } from &#39;react&#39;;

const Child = memo(function Child({ count }) {
  console.log(&#39;Child render&#39;);
  return &lt;div&gt;Child: {count}&lt;/div&gt;;
});

function App() {
  const [count, setCount] = useState(0);

  const handleClick = () =&gt; {
    setCount(count + 1);
  };

  return (
    &lt;div&gt;
      &lt;p&gt;count: {count}&lt;/p&gt;
      &lt;button onClick={handleClick}&gt;+1&lt;/button&gt;
      &lt;Child count={count} /&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<h2 id="React-的-Hooks-函数和普通函数有什么不同"><a href="#React-的-Hooks-函数和普通函数有什么不同" class="headerlink" title="React 的 Hooks 函数和普通函数有什么不同"></a>React 的 Hooks 函数和普通函数有什么不同</h2><p>react 的 hooks 函数和普通函数有以下不同：</p>
<ul>
<li>调用方式不同：hooks 函数组件内调用，普通函数不在组件内调用。</li>
<li>参数不同：hooks 函数参数为 props，普通函数参数为 url。</li>
<li>功能不同：hooks 函数能调用诸如 useState、useRef 等，普通函数则不能。由此可以通过内置的 Hooks 获得 Fiber 的访问方式，可以实现在组件级别存储数据的方案等。hooks 函数需要以 use 开头，普通函数则没有这个限制。</li>
</ul>
<h2 id="React-中的-key-有什么作用"><a href="#React-中的-key-有什么作用" class="headerlink" title="React 中的 key 有什么作用"></a>React 中的 key 有什么作用</h2><p>key 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。</p>
<p>在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。在 React Diff 算法中 React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染，提高 React 应用的性能。</p>
<h2 id="React-中的-diff-算法"><a href="#React-中的-diff-算法" class="headerlink" title="React 中的 diff 算法"></a>React 中的 diff 算法</h2><p>React 中的 Diff 算法是同层比较算法，它可以实现时间复杂度为 O(n)的算法，其中 n 是树中节点的总数。</p>
<p>React 为了性能优化，会在内存中维护一个虚拟 DOM，当有变动发生时，会通过 Diff 算法对新旧 DOM 树进行比较，找出需要更新的部分，再把需要更新的部分放到真实的 DOM 树上，这样就完成了一次 UI 的更新。</p>
<h2 id="React-中的-setState-是同步还是异步的"><a href="#React-中的-setState-是同步还是异步的" class="headerlink" title="React 中的 setState 是同步还是异步的"></a>React 中的 setState 是同步还是异步的</h2><p>在 React 中，setState 并不总是同步的，它可能是异步的。</p>
<p>React 为了提高性能，会将多个 setState()调用合并成一个调用，而不是每次状态变化都执行一次 render()方法。</p>
<p>但是，当你想要在调用 setState()后获取最新的状态数据时，这种合并机制就会导致你无法立即拿到最新的状态数据。</p>
<p>React 为了解决这个问题，提供了 setState()的第二个参数，它可以接受一个回调函数，该回调函数会在 setState()完成合并并重新渲染组件后执行。</p>
<h2 id="React-中的事件处理"><a href="#React-中的事件处理" class="headerlink" title="React 中的事件处理"></a>React 中的事件处理</h2><p>React 中的事件处理和原生的事件处理有以下不同：</p>
<ul>
<li>React 事件的命名采用小驼峰式（camelCase），而不是纯小写。</li>
<li>使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串。</li>
<li>在 React 中你不能通过返回 false 的方式阻止默认行为，你必须明确的使用 preventDefault。</li>
<li>在 React 中你不能通过返回 false 的方式阻止事件冒泡，你必须明确的调用 stopPropagation。</li>
</ul>
<h2 id="React-中的事件合成"><a href="#React-中的事件合成" class="headerlink" title="React 中的事件合成"></a>React 中的事件合成</h2><p>React 中的事件是通过事件委托的方式处理的，它使用了统一的事件监听器，将所有的事件都绑定到了 document 上，而并非将事件绑定到每一个节点上。</p>
<p>React 中的事件委托是基于合成事件的，合成事件是 React 根据 W3C 标准制定的一套合成事件接口，它屏蔽了底层浏览器的 API 细节，提供了一套更简单的事件处理机制，并且它是跨浏览器的。</p>
<h2 id="React-中的事件绑定"><a href="#React-中的事件绑定" class="headerlink" title="React 中的事件绑定"></a>React 中的事件绑定</h2><p>React 中的事件绑定和原生的事件绑定有以下不同：</p>
<ul>
<li>React 事件的命名采用小驼峰式（camelCase），而不是纯小写。</li>
<li>使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串。</li>
</ul>
</article></div></div><footer id="footer"><div class="container"><div class="copy">Copyright &copy; 2023 Ray0324</div><nav><a href="/">首页</a><a href="/archives/">归档</a><a href="/tags/">标签</a><a href="/about/">关于</a></nav></div></footer><script src="/lib/jquery/jquery.min.js"></script><script src="/lib/highlight/highlight.pack.js"></script><script src="/lib/push.js"></script><script src="/js/nano.js"></script></body></html>